# æ•°æ®ä¸€è‡´æ€§

> **AIç”Ÿæˆå£°æ˜**: æœ¬æ–‡æ¡£ç”±AIè¾…åŠ©ç”Ÿæˆï¼Œæ—¨åœ¨æä¾›æ•°æ®ä¸€è‡´æ€§çš„åŸºç¡€çŸ¥è¯†å’Œå®è·µæŒ‡å—ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« èŠ‚çš„å­¦ä¹ ,ä½ å°†èƒ½å¤Ÿ:

- ç†è§£æ•°æ®ä¸€è‡´æ€§çš„æ¦‚å¿µå’Œé‡è¦æ€§
- æŒæ¡CAPç†è®ºå’ŒBASEç†è®º
- äº†è§£æ•°æ®ä¸€è‡´æ€§ä¿è¯æœºåˆ¶
- å­¦ä¹ åˆ†å¸ƒå¼äº‹åŠ¡å’Œæœ€ç»ˆä¸€è‡´æ€§

## ğŸ“š æ•°æ®ä¸€è‡´æ€§æ¦‚å¿µ

### ä¸€è‡´æ€§ç±»å‹

#### 1. å¼ºä¸€è‡´æ€§

æ‰€æœ‰èŠ‚ç‚¹åœ¨åŒä¸€æ—¶åˆ»çœ‹åˆ°ç›¸åŒçš„æ•°æ®ã€‚

**ç‰¹ç‚¹**:
- æ•°æ®å®Œå…¨ä¸€è‡´
- æ€§èƒ½å½±å“è¾ƒå¤§
- å¯ç”¨æ€§å¯èƒ½å—å½±å“

#### 2. å¼±ä¸€è‡´æ€§

ç³»ç»Ÿä¸ä¿è¯ç«‹å³ä¸€è‡´,ä½†ä¿è¯æœ€ç»ˆä¸€è‡´ã€‚

**ç‰¹ç‚¹**:
- æ€§èƒ½å¥½
- å¯èƒ½å‡ºç°çŸ­æš‚ä¸ä¸€è‡´
- æœ€ç»ˆä¼šè¾¾åˆ°ä¸€è‡´

#### 3. æœ€ç»ˆä¸€è‡´æ€§

ç³»ç»Ÿä¿è¯åœ¨æ²¡æœ‰æ–°çš„æ›´æ–°æ“ä½œå,æœ€ç»ˆä¼šè¾¾åˆ°ä¸€è‡´çŠ¶æ€ã€‚

**ç‰¹ç‚¹**:
- æ€§èƒ½å¥½
- å»¶è¿Ÿä¸€è‡´æ€§
- é€‚åˆå¤§å¤šæ•°åœºæ™¯

### ä¸€è‡´æ€§åœºæ™¯

- **ä¸»ä»å¤åˆ¶**: ä¸»åº“å†™å…¥,ä»åº“åŒæ­¥
- **åˆ†å¸ƒå¼ç¼“å­˜**: ç¼“å­˜ä¸æ•°æ®åº“ä¸€è‡´
- **åˆ†å¸ƒå¼å­˜å‚¨**: å¤šå‰¯æœ¬æ•°æ®ä¸€è‡´
- **åˆ†å¸ƒå¼äº‹åŠ¡**: è·¨æœåŠ¡æ•°æ®ä¸€è‡´

## ğŸ” CAPç†è®º

### CAPå®šç†

åœ¨ä¸€ä¸ªåˆ†å¸ƒå¼ç³»ç»Ÿä¸­,ä»¥ä¸‹ä¸‰ä¸ªç‰¹æ€§æœ€å¤šåªèƒ½åŒæ—¶æ»¡è¶³ä¸¤ä¸ª:

- **C (Consistency)**: ä¸€è‡´æ€§
- **A (Availability)**: å¯ç”¨æ€§
- **P (Partition tolerance)**: åˆ†åŒºå®¹é”™æ€§

### CAPç»„åˆ

#### CPç³»ç»Ÿ

ä¿è¯ä¸€è‡´æ€§å’Œåˆ†åŒºå®¹é”™æ€§,ç‰ºç‰²å¯ç”¨æ€§ã€‚

**ç¤ºä¾‹**: åˆ†å¸ƒå¼æ•°æ®åº“(å¦‚MongoDBã€HBase)

#### APç³»ç»Ÿ

ä¿è¯å¯ç”¨æ€§å’Œåˆ†åŒºå®¹é”™æ€§,ç‰ºç‰²ä¸€è‡´æ€§ã€‚

**ç¤ºä¾‹**: DNSç³»ç»Ÿã€CDNç³»ç»Ÿ

#### CAç³»ç»Ÿ

ä¿è¯ä¸€è‡´æ€§å’Œå¯ç”¨æ€§,ä¸é€‚åˆåˆ†å¸ƒå¼ç¯å¢ƒã€‚

**æ³¨æ„**: å®é™…åˆ†å¸ƒå¼ç³»ç»Ÿå¿…é¡»æ»¡è¶³P,æ‰€ä»¥CAç»„åˆåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ä¸å­˜åœ¨ã€‚

## ğŸ—ï¸ BASEç†è®º

### BASEå«ä¹‰

- **BA (Basically Available)**: åŸºæœ¬å¯ç”¨
- **S (Soft state)**: è½¯çŠ¶æ€
- **E (Eventual consistency)**: æœ€ç»ˆä¸€è‡´æ€§

### BASE vs ACID

| ç‰¹æ€§ | ACID | BASE |
|------|------|------|
| ä¸€è‡´æ€§ | å¼ºä¸€è‡´æ€§ | æœ€ç»ˆä¸€è‡´æ€§ |
| å¯ç”¨æ€§ | ä½(å¼ºä¸€è‡´å¯¼è‡´) | é«˜ |
| äº‹åŠ¡ | æ”¯æŒ | ä¸æ”¯æŒ |
| æ€§èƒ½ | ä½ | é«˜ |

## ğŸ’¾ æ•°æ®ä¸€è‡´æ€§ä¿è¯

### 1. ä¸»ä»å¤åˆ¶ä¸€è‡´æ€§

#### åŒæ­¥å¤åˆ¶

ä¸»åº“ç­‰å¾…æ‰€æœ‰ä»åº“ç¡®è®¤åæ‰è¿”å›æˆåŠŸã€‚

```sql
-- MySQLåŠåŒæ­¥å¤åˆ¶
SET GLOBAL rpl_semi_sync_master_enabled = 1;
SET GLOBAL rpl_semi_sync_slave_enabled = 1;
```

**ä¼˜ç‚¹**: æ•°æ®ä¸€è‡´æ€§å¥½
**ç¼ºç‚¹**: æ€§èƒ½å½±å“,å¯ç”¨æ€§é™ä½

#### å¼‚æ­¥å¤åˆ¶

ä¸»åº“ä¸ç­‰å¾…ä»åº“ç¡®è®¤ç›´æ¥è¿”å›ã€‚

**ä¼˜ç‚¹**: æ€§èƒ½å¥½,å¯ç”¨æ€§é«˜
**ç¼ºç‚¹**: å¯èƒ½ä¸¢å¤±æ•°æ®

### 2. åˆ†å¸ƒå¼é”

ä¿è¯åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹èƒ½ä¿®æ”¹æ•°æ®ã€‚

```python
import redis
import time
import uuid

class DistributedLock:
    def __init__(self, redis_client, key, timeout=10):
        self.redis = redis_client
        self.key = f"lock:{key}"
        self.timeout = timeout
        self.identifier = str(uuid.uuid4())
    
    def acquire(self, block=True, timeout=None):
        """è·å–é”"""
        end_time = time.time() + (timeout or self.timeout)
        
        while True:
            # å°è¯•è·å–é”
            if self.redis.set(self.key, self.identifier, nx=True, ex=self.timeout):
                return True
            
            if not block or time.time() > end_time:
                return False
            
            time.sleep(0.001)  # çŸ­æš‚ç­‰å¾…åé‡è¯•
    
    def release(self):
        """é‡Šæ”¾é”"""
        # ä½¿ç”¨Luaè„šæœ¬ä¿è¯åŸå­æ€§
        lua_script = """
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
        """
        self.redis.eval(lua_script, 1, self.key, self.identifier)

# ä½¿ç”¨ç¤ºä¾‹
redis_client = redis.Redis()
lock = DistributedLock(redis_client, 'user:123')

if lock.acquire():
    try:
        # ä¿®æ”¹æ•°æ®
        update_user_data('user:123')
    finally:
        lock.release()
```

### 3. ç‰ˆæœ¬æ§åˆ¶

ä½¿ç”¨ç‰ˆæœ¬å·æˆ–æ—¶é—´æˆ³ä¿è¯æ•°æ®ä¸€è‡´æ€§ã€‚

```python
class VersionedData:
    def __init__(self):
        self.data = {}
        self.versions = {}
    
    def update(self, key, value, expected_version=None):
        """æ›´æ–°æ•°æ®(å¸¦ç‰ˆæœ¬æ£€æŸ¥)"""
        current_version = self.versions.get(key, 0)
        
        # ä¹è§‚é”æ£€æŸ¥
        if expected_version is not None and current_version != expected_version:
            raise ValueError("ç‰ˆæœ¬ä¸åŒ¹é…,æ›´æ–°å¤±è´¥")
        
        # æ›´æ–°æ•°æ®å’Œç‰ˆæœ¬
        self.data[key] = value
        self.versions[key] = current_version + 1
        
        return self.versions[key]
    
    def get(self, key):
        """è·å–æ•°æ®å’Œç‰ˆæœ¬"""
        return {
            'value': self.data.get(key),
            'version': self.versions.get(key, 0)
        }

# ä½¿ç”¨ç¤ºä¾‹
store = VersionedData()

# ç¬¬ä¸€æ¬¡æ›´æ–°
version = store.update('user:123', {'name': 'Alice'})

# è¯»å–æ•°æ®
data = store.get('user:123')
current_version = data['version']

# å¸¦ç‰ˆæœ¬æ£€æŸ¥çš„æ›´æ–°
try:
    store.update('user:123', {'name': 'Bob'}, expected_version=current_version)
except ValueError as e:
    print(f"æ›´æ–°å¤±è´¥: {e}")
```

### 4. ä¸¤é˜¶æ®µæäº¤(2PC)

åˆ†å¸ƒå¼äº‹åŠ¡åè®®,ä¿è¯æ‰€æœ‰èŠ‚ç‚¹åŒæ—¶æäº¤æˆ–å›æ»šã€‚

```python
class TwoPhaseCommit:
    def __init__(self, participants):
        self.participants = participants
        self.transaction_id = None
    
    def prepare(self, transaction_id):
        """é˜¶æ®µ1: å‡†å¤‡é˜¶æ®µ"""
        self.transaction_id = transaction_id
        prepare_results = []
        
        for participant in self.participants:
            try:
                result = participant.prepare(transaction_id)
                prepare_results.append(result)
            except Exception as e:
                # ä»»ä¸€èŠ‚ç‚¹å¤±è´¥,å›æ»šæ‰€æœ‰
                self.rollback(transaction_id)
                raise
        
        return all(prepare_results)
    
    def commit(self, transaction_id):
        """é˜¶æ®µ2: æäº¤é˜¶æ®µ"""
        if not self.prepare(transaction_id):
            return False
        
        commit_results = []
        for participant in self.participants:
            try:
                result = participant.commit(transaction_id)
                commit_results.append(result)
            except Exception as e:
                # æäº¤å¤±è´¥,å°è¯•å›æ»š
                self.rollback(transaction_id)
                raise
        
        return all(commit_results)
    
    def rollback(self, transaction_id):
        """å›æ»š"""
        for participant in self.participants:
            try:
                participant.rollback(transaction_id)
            except Exception as e:
                print(f"å›æ»šå¤±è´¥: {e}")
```

### 5. æœ€ç»ˆä¸€è‡´æ€§å®ç°

#### æ¶ˆæ¯é˜Ÿåˆ—ä¿è¯

```python
import json
from kafka import KafkaProducer, KafkaConsumer

class EventualConsistency:
    def __init__(self, kafka_producer, kafka_consumer):
        self.producer = kafka_producer
        self.consumer = kafka_consumer
    
    def update_primary(self, key, value):
        """æ›´æ–°ä¸»æ•°æ®"""
        # 1. æ›´æ–°ä¸»åº“
        update_database(key, value)
        
        # 2. å‘é€åŒæ­¥æ¶ˆæ¯
        event = {
            'key': key,
            'value': value,
            'timestamp': time.time()
        }
        self.producer.send('data_sync', json.dumps(event).encode())
    
    def sync_to_cache(self):
        """åŒæ­¥åˆ°ç¼“å­˜"""
        for message in self.consumer:
            event = json.loads(message.value.decode())
            
            # æ›´æ–°ç¼“å­˜
            update_cache(event['key'], event['value'])
            
            # ç¡®è®¤æ¶ˆè´¹
            self.consumer.commit()
```

#### ç‰ˆæœ¬å‘é‡

```python
class VersionVector:
    def __init__(self, node_id):
        self.node_id = node_id
        self.vector = {node_id: 0}
    
    def increment(self):
        """é€’å¢ç‰ˆæœ¬"""
        self.vector[self.node_id] = self.vector.get(self.node_id, 0) + 1
    
    def update(self, other_vector):
        """åˆå¹¶ç‰ˆæœ¬å‘é‡"""
        for node, version in other_vector.items():
            current_version = self.vector.get(node, 0)
            self.vector[node] = max(current_version, version)
    
    def compare(self, other_vector):
        """æ¯”è¾ƒç‰ˆæœ¬å‘é‡"""
        for node in set(self.vector.keys()) | set(other_vector.keys()):
            v1 = self.vector.get(node, 0)
            v2 = other_vector.get(node, 0)
            
            if v1 < v2:
                return -1  # å°äº
            elif v1 > v2:
                return 1  # å¤§äº
        
        return 0  # ç›¸ç­‰
```

## ğŸš€ å®è·µåº”ç”¨

### åˆ†å¸ƒå¼äº‹åŠ¡è§£å†³æ–¹æ¡ˆ

#### Sagaæ¨¡å¼

```python
class SagaOrchestrator:
    def __init__(self):
        self.steps = []
        self.compensations = []
    
    def add_step(self, action, compensation):
        """æ·»åŠ æ­¥éª¤"""
        self.steps.append(action)
        self.compensations.append(compensation)
    
    def execute(self):
        """æ‰§è¡ŒSaga"""
        completed_steps = []
        
        try:
            for i, step in enumerate(self.steps):
                step()  # æ‰§è¡Œæ­¥éª¤
                completed_steps.append(i)
            
            return True
        except Exception as e:
            # è¡¥å¿å·²å®Œæˆçš„æ­¥éª¤
            for i in reversed(completed_steps):
                self.compensations[i]()
            raise e
```

### åˆ†å¸ƒå¼é”åº”ç”¨

```python
# ä½¿ç”¨åˆ†å¸ƒå¼é”ä¿è¯åº“å­˜æ‰£å‡ä¸€è‡´æ€§
def deduct_inventory(product_id, quantity):
    lock_key = f"inventory_lock:{product_id}"
    lock = DistributedLock(redis_client, lock_key, timeout=10)
    
    if lock.acquire():
        try:
            # æ£€æŸ¥åº“å­˜
            current_stock = get_inventory(product_id)
            if current_stock < quantity:
                raise ValueError("åº“å­˜ä¸è¶³")
            
            # æ‰£å‡åº“å­˜
            update_inventory(product_id, current_stock - quantity)
            return True
        finally:
            lock.release()
    else:
        raise Exception("è·å–é”å¤±è´¥")
```

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. æ€§èƒ½æƒè¡¡

- **å¼ºä¸€è‡´æ€§**: æ€§èƒ½å½±å“å¤§
- **æœ€ç»ˆä¸€è‡´æ€§**: æ€§èƒ½å¥½,ä½†éœ€è¦å¤„ç†ä¸ä¸€è‡´

### 2. æ•…éšœå¤„ç†

- **æ•°æ®å†²çª**: è®¾è®¡å†²çªè§£å†³ç­–ç•¥
- **è¡¥å¿æœºåˆ¶**: å¤±è´¥åè¡¥å¿å¤„ç†
- **é‡è¯•æœºåˆ¶**: å¤±è´¥åé‡è¯•

### 3. ä¸šåŠ¡åœºæ™¯

- **é‡‘èç³»ç»Ÿ**: å¼ºä¸€è‡´æ€§
- **ç”µå•†ç³»ç»Ÿ**: æœ€ç»ˆä¸€è‡´æ€§
- **ç¤¾äº¤ç³»ç»Ÿ**: å¼±ä¸€è‡´æ€§

## ğŸ“– æ¨èèµ„æº

- [CAPç†è®ºè¯¦è§£](https://en.wikipedia.org/wiki/CAP_theorem)
- [åˆ†å¸ƒå¼ç³»ç»Ÿä¸€è‡´æ€§](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)
- ã€Šæ•°æ®å¯†é›†å‹åº”ç”¨ç³»ç»Ÿè®¾è®¡ã€‹ä¹¦ç±

## ğŸ’¡ ä¸‹ä¸€æ­¥

- å­¦ä¹ [é«˜å¯ç”¨æ¶æ„è®¾è®¡](./architecture-design.md)
- æ·±å…¥äº†è§£åˆ†å¸ƒå¼ç³»ç»Ÿä¸€è‡´æ€§

---

*æœ€åæ›´æ–°æ—¶é—´: 2025-01-20*

